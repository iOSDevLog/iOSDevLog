{"name":"Iosdevlog","tagline":"iOSDevLog Source Code","body":"Session 226\r\n\r\nWWDC 2015\r\n\r\nOperations are a flexible way to model your app's business logic, but they can do so much more. See how NSOperation forms the heart of the WWDC app, and how using features like dependencies, readiness, and composition allow you to quickly and easily build dynamic and complex apps.\r\n\r\n[ Music ]\r\n\r\n(Applause) PHILIPPE HAUSLER: Good morning.\r\n\r\nMy name is Philippe Hausler.\r\n\r\nI work in the Frameworks Group, on Foundation.\r\n\r\nAnd today we are going to talk about NSOperation and NSOperationQueue.\r\n\r\nThese are two extremely powerful classes that can transform your application from running tasks linearly to a hybrid scenario of both the object-orientated and functionally asynchronous concepts.\r\n\r\nNow, I am pretty sure that all of you have seen this application.\r\n\r\nThe WWDC app uses NSOperation and NSOperationQueue extensively.\r\n\r\nTo be able to accomplish numerous different tasks all the way from downloading content from the Internet all the way to synchronizing the database as well as even concepts like presenting alerts or displaying videos.\r\n\r\nAnd here to take you more in depth of NSOperation and NSOperationQueue and how it actually was used to be able to implement the WWDC app is Dave DeLong.\r\n\r\nDave?\r\n\r\n[ Applause ]\r\n\r\nDAVE DeLONG: Thanks, Philippe.\r\n\r\n[ Silence ]\r\n\r\nSo, my name is Dave DeLong, and I am a Frameworks Evangelist at Apple, and I am also the primary engineer on the WWDC app, which hopefully you are all familiar with.\r\n\r\nToday we are going to be covering three main areas of the WWDC app and NSOperation.\r\n\r\nFirst, we are going to go over the core concepts of NSOperation and how you can understand its API and take advantage of its powerful state machine.\r\n\r\nNext, we are going to go beyond those basics and look at the challenges of the WWDC app across and how we solved them.\r\n\r\nAnd finally, we are going to talk about some sample code that we have provided for you.\r\n\r\nSo first, let's look at some core concepts.\r\n\r\nAny time you use an NSOperation, you will always be using an NSOperationQueue.\r\n\r\nAnd the way to think about an NSOperationQueue is that it's a high-level dispatch queue.\r\n\r\nHopefully you are all familiar with dispatch queues from using Grand Central Dispatch.\r\n\r\nNow, by providing a wrapper around an NSOperationQueue, we can gain some additional functionality.\r\n\r\nFor example, NSOperationQueue makes it very easy to cancel operations that have not yet begun executing.\r\n\r\nWhile you can perform cancellation of dispatch blocks, it is somewhat tricky to do so, but NSOperationQueue makes this quite easy.\r\n\r\nAnother thing that you get with NSOperationQueue is a property called the max concurrent operation count.\r\n\r\nAnd to understand what this is, let's take a look at a little animation.\r\n\r\nIf we set the max concurrent operation count of an NSOperationQueue to be 1, then we essentially make our NSOperationQueue into a serial operation queue.\r\n\r\nSo let's load up a bunch of operations onto this queue.\r\n\r\nWith the max concurrent operation count of 1, the queue will pull off these operations one by one and execute them in order.\r\n\r\nThe next operation will not begin executing until the previous one has finished.\r\n\r\nThat's a serial queue.\r\n\r\nHowever, by default, the value of this property is a default value, which means as many as the system allows.\r\n\r\nSo this means that our operation queue can perform multiple operations simultaneously as system resources allow.\r\n\r\nSo in this case, our operation queue might be performing two operations at once.\r\n\r\nThe ability to change the behavior of an operation queue like this can be very powerful.\r\n\r\nWe don't have to decide this at creation time of our operation queue.\r\n\r\nSo that's NSOperationQueue.\r\n\r\nNow let's take a look at NSOperation.\r\n\r\nWhere the queue is a high-level wrapper around a dispatch queue, you can think of an NSOperation as a high-level wrapper around a dispatch block.\r\n\r\nNow, in general, NSOperations run for a little bit longer than you would expect a block to run, so blocks usually take a few nanoseconds, maybe at most a millisecond, to execute.\r\n\r\nNSOperations, on the other hand, can be much longer, for anywhere from a couple of milliseconds to even several minutes, as we will talk about later.\r\n\r\nThe other thing that's really nice about an NSOperation is that since it's a class, you can subclass it and provide your own custom logic on how it executes.\r\n\r\nSo in order to subclass NSOperation, let's take a look at its lifecycle.\r\n\r\nWhen you create an NSOperation, it always starts off in a state that we call the pending state.\r\n\r\nSo this is the operation when it's initialized and as it's being put onto its operation queue.\r\n\r\nNow, at some point, the operation is going to become ready to execute, and it enters the ready state.\r\n\r\nAnd after it becomes ready, the operation queue will pull it off of the queue and begin executing it.\r\n\r\nAnd like I said, this execution can be anywhere from a couple of milliseconds to several minutes to even longer.\r\n\r\nAfter execution finishes, the operation enters the finish state, its final state.\r\n\r\nSo that's pretty simple.\r\n\r\nThe other thing that an operation can do is at any point, it can enter a canceled state.\r\n\r\nSo let's take a look at cancellation.\r\n\r\nCancellation on an NSOperation is defined as a simple Boolean property, is canceled.\r\n\r\nAnd the important thing to understand about this property is that it only changes the state of the property.\r\n\r\nWhen you cancel an operation, all that's happening is that a Boolean value is getting flipped.\r\n\r\nSo as you subclass NSOperation, it is up to you to decide what it means for your NSOperation to be canceled.\r\n\r\nSo, for example, if your operation is performing a network task, then maybe canceling your operation is akin to canceling your network communication.\r\n\r\nOr perhaps if you are performing some sort of database transaction in your operation, then perhaps canceling your operation would be like discarding that transaction.\r\n\r\nSo as you subclass NSOperation, be sure to observe this value changing and react appropriately if there's any reaction you need to do.\r\n\r\nThe other thing to be aware of with cancellation is it is susceptible to race conditions.\r\n\r\nWhat do I mean by this?\r\n\r\nWell, let's consider an operation that's executing in the background, and maybe in your UI you have a cancel button that would cancel this operation.\r\n\r\nIf the user taps the cancel button, it's going to take a small amount of time for that message, to cancel, to move from the main queue to the operation in the background.\r\n\r\nAnd if in that small window of time your operation finishes executing, then your operation will actually never be canceled because an operation cannot go from the finished state to the canceled state.\r\n\r\nSo it is important to understand that just because you try to cancel an operation, there are some cases where it won't actually cancel.\r\n\r\nHowever, if you do need to cancel an operation, it is very easy to do so.\r\n\r\nAll you need to do is call the cancel method.\r\n\r\nSo that's cancellation.\r\n\r\nNow let's take a look at this other interesting state called Ready.\r\n\r\nThe readiness of an NSOperation, like cancellation, is defined as a simple Boolean property, is ready.\r\n\r\nAnd what this property means is that the operation is ready to execute.\r\n\r\nSo let's take a look at how this interacts with operations on an operation queue.\r\n\r\nSo again, we've got our serial operation queue, and we are going to load up a bunch of operations, and they are all in the initial blue pending state.\r\n\r\nNow, the first operation to enter the ready state is the first operation that will be executed, even, for example, in this case, if it's the fourth operation that was put onto the queue.\r\n\r\nSo once the operation is ready, it begins executing.\r\n\r\nThen, as other operations become ready, they are pulled off the queue and executed.\r\n\r\nAnd in this case, since we have a serial queue, only executing one at a time, if two operations become ready at the same time, then the first one that has a higher priority will be pulled off first, and then the second one will be executed.\r\n\r\nAnd then, as the other operations become ready, they are also pulled off the queue and executed.\r\n\r\nSo that's brief look at readiness.\r\n\r\nNow, what can we do with this?\r\n\r\nWell, we can make dependencies.\r\n\r\nDependencies are a way for us to express a strict ordering between our operations, that first we want to execute this thing, and then we want to execute that thing.\r\n\r\nAnd the neat thing about dependencies is they provide the base definition for what it means for an operation to be ready.\r\n\r\nBy default, an operation will become ready if all of its dependencies have finished executing.\r\n\r\nThis is behavior that you get for free.\r\n\r\nThe other neat thing about dependencies is that they are not limited by operation queues.\r\n\r\nNow, what do I mean by this?\r\n\r\nIf you have two operation queues in your application, operations in the first queue can be dependent on the operations in the second queue.\r\n\r\nAnd we are going to see later how this can enable some really powerful patterns.\r\n\r\nNow, setting up dependencies amongst your operations, again, is extremely simple.\r\n\r\nAll we need to do is use the add dependency method.\r\n\r\nSo in this case, operation B will become dependent on the successful exectution of operation A.\r\n\r\nAnd so operation B will not execute until after operation A.\r\n\r\nThis is guaranteed.\r\n\r\nNow, with dependencies, we can run into a couple of problems, like operation deadlock.\r\n\r\nSo if I have an operation A and another operation B that is dependent upon the execution of A, this is fine.\r\n\r\nHowever, if I inadvertently make A also dependent on B, then these two operations will never execute because they will both be waiting on each other to finish, and since they are both waiting, they will both never start.\r\n\r\nSo as you are setting up dependencies in your application, don't do this.\r\n\r\nNow, the WWDC app uses dependencies all over the place.\r\n\r\nAnd a really simple example is what happens when you tap the \"add to favorites\" button on a session in the app, which hopefully you all did for this session.\r\n\r\nWhen you tap that button, we're going to first create an operation called the login operation.\r\n\r\nThis is an operation that guarantees that you have logged into the app with your developer name and password.\r\n\r\nNext, we are going to create another operation called the User Info operation.\r\n\r\nThis is an operation that guarantees that the user name and password are actually a developer username and password and not, for example, your iTunes username and password.\r\n\r\nSo your Apple ID is an appropriate developer Apple ID.\r\n\r\nNow, favorites in the WWDC app are stored in CloudKit, so we also need another operation to make sure that we have access to your iCloud account.\r\n\r\nSo this happens silently, because we are not requesting permission to see your first name and last name in the app, so we need to make sure that you have an iCloud account.\r\n\r\nAnd finally, we can set up the save favorite operation, and this is dependent on the successful completion of verifying that you are a developer and the successful completion of verifying that you have an iCloud account.\r\n\r\nSo that's a simple example.\r\n\r\nLet's take a look at a bit more complex one.\r\n\r\nWhen the WWDC app starts up, there's a bunch of setup that we need to do.\r\n\r\nFirst, we are going to download a small configuration file, and this file will tell us small things like what's the most recently supported version of the application, what features we have enabled, and so on.\r\n\r\nSo after we download this file, we are going to perform a version check to make sure that you are running the latest version of the WWDC app.\r\n\r\nAnd then after we check the version of the app, we can start downloading useful pieces of information, such as the news that we show in the News tab and the schedule for the conference.\r\n\r\nAfter we've downloaded the schedule, then we can start importing any favorites that you've saved to iCloud, any feedback that you've submitted so you can see it in the app, and we are also going to start downloading the list of videos.\r\n\r\nAll of these things require the schedule to first be in place.\r\n\r\nAnd then finally, we can save our NSManaged object context, where we are saving all of this information.\r\n\r\nSo let's see how dependencies and operation lifecycle affect the execution of these operations.\r\n\r\nAnd we are going to move them all into the Pending Operations state.\r\n\r\nNow, the first operation to download the app settings has no dependencies, so it immediately becomes ready to execute.\r\n\r\nAnd so our operation queue is going to pull it off, execute it, and then it's going to finish.\r\n\r\nNow, when it finishes, the version check operation also immediately becomes ready to execute, and so it's going to get pulled off the queue and executed.\r\n\r\nWhen it finishes, the next three operations simultaneously become ready to execute.\r\n\r\nSo they're going to start executing.\r\n\r\nAnd as they finish executing, more and more operations will become ready to execute.\r\n\r\nThey will be pulled off the queue and executed.\r\n\r\nNow, the important thing to realize here and to notice is that this final operation to save our context does not become ready to execute until everything else has already finished.\r\n\r\nBy using dependencies, we can guarantee that things happen in the correct order and that nothing will get out of order.\r\n\r\nSo now that this one is ready, it can be executed, and it can finish.\r\n\r\nAnd App Start-up can continue.\r\n\r\nSo that's a look at dependencies.\r\n\r\nOverall, NSOperations are a fantastic way to abstract logic in your code.\r\n\r\nBy putting our logic inside of operations, it makes it easier to simplify these logic changes because we are dealing with isolated pieces of work, much like we do when we are dealing with a block.\r\n\r\nAs an example of this, the WWDC app this year moved from being from saving your favorites and feedback on a custom backend, to being on CloudKit.\r\n\r\nNow, at this point I want you all to think about, what would it take to move your application from a custom, from whatever service you are using now to CloudKit?\r\n\r\nAnd if you are suddenly panicking, and all of the places in your code where you've got network communication, and all these dependencies on, you know, the intricacies of your server provider, then this is a good sign that you should be using operations.\r\n\r\nIn the WWDC app, all of our network communication is hidden behind operations, which means that in order to change the backend from using a custom service to using CloudKit, all we had to do was rewrite four small classes.\r\n\r\nIt took us less than a day and then a couple more days to successfully test our changes.\r\n\r\nIt was a simple, trivial change.\r\n\r\nNow, in all of this, you might be wondering, well, what about Grand Central Dispatch?\r\n\r\nGrand Central Dispatch absolutely has its place.\r\n\r\nIn fact, when you download the sample code for this presentation and look through it, you will see places where we are using Grand Central Dispatch in that sample code for things that are not really appropriate to NSOperations.\r\n\r\nSo for example, anytime you simply need to bounce a method call from one queue to another queue, you don't need to wrap that in an operation.\r\n\r\nThat's something you want to keep fast and very lightweight.\r\n\r\nOr if you are doing anything with semaphores or dispatch group, these are all perfect use cases for Grand Central Dispatch.\r\n\r\nSo that's a look at the basics.\r\n\r\nLet's go beyond them.\r\n\r\nNow, one of the things that we realized in the WWDC app is that there are places where we want to have UI interaction but still have it participate in the operation chain.\r\n\r\nSo for example, authentication.\r\n\r\nWe talked earlier about saving a favorite.\r\n\r\nWe need to make sure that you are logged in.\r\n\r\nBut what if you are not?\r\n\r\nWell, we realized that we can put UI elements, UI functionality within our operations.\r\n\r\nSo for example, the authentication dialogue that slides up in the WWDC app is actually an NSOperation.\r\n\r\nOr anytime that you are watching a video in the WWDC app, we encapsulated this inside a \"watch video\" operation.\r\n\r\nSo all we need to do is create one of these operations with the appropriate video asset and put it on our operation queue, and everything else will just fall into place.\r\n\r\nEven more broadly, any time you see an alert in the WWDC app, this is something that we thought was also a really good use case for putting UI inside an NSOperation.\r\n\r\nAnd we discovered that the underlying principle we found here was that when we're dealing with any sort of modal UI, so a UI that takes over generally the entire real estate of your application, this is an excellent thing to encapsulate inside of an NSOperation.\r\n\r\nSo to reiterate, the first time you launch the WWDC app, you saw this dialogue asking if we could collect some simple usage data on how you are using the app.\r\n\r\nThis dialogue that appears, this UI alert controller, is actually being run from inside an NSOperation.\r\n\r\nOr the login sheet.\r\n\r\nIf you try to add something to Favorites or leave feedback on a session, this is also an NSOperation.\r\n\r\nThe next thing we encountered is that there are some times we want to perform simple pieces of logic as a block, but we also wanted to participate inside the operation mechanism.\r\n\r\nSo we turned to block operations, NSBlock operation and other custom operations that we created.\r\n\r\nSo this is really just an NSOperation to execute a block.\r\n\r\nAnd you may be asking, well, if NSOperation is just an abstraction around a block, why would I then return to using blocks inside an NSOperation?\r\n\r\nAnd that's because by putting a block inside an NSOperation, you gain all of the great features of NSOperation for that block that you do for NSOperation, such as dependencies.\r\n\r\nLet's take a look at what we can do with this and see what happens when you tap the Leave Feedback button in the WWDC app.\r\n\r\nWell, the Leave Feedback button wants to perform a segue.\r\n\r\nIt wants to present the view controller where you can leave some five-star ratings or maybe four if they were really good but not truly excellent.\r\n\r\nWe want to perform this segue.\r\n\r\nSo we are going to put this segue inside of a block, and then we are going to put this block inside of a block operation.\r\n\r\nNow, we only want to allow you to leave feedback if you've signed into the app.\r\n\r\nSo we need to verify that you've signed in with your developer account, just like we do when you save a favorite.\r\n\r\nAnd in order to verify that you have a developer account, we need to make sure that you are logged in at all.\r\n\r\nSo by putting the perform segue call inside of a block operation, we can guarantee that we will never present the login sheet until after you have logged in.\r\n\r\nThis is really powerful.\r\n\r\nWe have described a really complex behavior, a sequence of things that must occur simply by using operations and dependencies.\r\n\r\nNow, as we were writing the WWDC app, we noticed that there were some cases where we were doing a lot of the same operations over and over again.\r\n\r\nSo for example, we've already seen this login and user info operation a couple of times.\r\n\r\nSo we thought wouldn't it be great if there were a way where we could just automatically have those operations created?\r\n\r\nSo we came up with a way for an operation to generate its own dependencies.\r\n\r\nIn other words, we're expressing the idea that we never want to execute this thing without always executing this other thing.\r\n\r\nSo again, let's take a look at saving a favorite to CloudKit, or perhaps downloading a pass, or really, anything in the WWDC app that requires you to be logged in.\r\n\r\nSo when you tap the \"add to favorites\" button, all we are really doing is creating a single operation to save the favorite.\r\n\r\nAnd this is going to encapsulate some small pieces of information, the session identifier and whether or not you want it added to favorites or removed from favorites, a little Boolean flag.\r\n\r\nNow, this \"save favorite\" operation knows that it requires permission to run, so it is automatically going to generate two dependencies, the one to check that you are a developer and the other to guarantee that we have access to your iCloud account.\r\n\r\nNow, the operation to guarantee that you are a developer itself needs to guarantee that you are logged in, so it generates its own dependency to make sure you are logged in.\r\n\r\nAnd so we are able to keep our app code quite simple.\r\n\r\nWe only need to create a single operation, and then it automatically generates its own dependencies.\r\n\r\nAnd perhaps later, if we decide to remove the requirement that you need to be logged in to save a favorite, then we simply remove the small line of code that instructs this favorite operation to generate that particular dependency, and we have now removed that requirement across the entire application.\r\n\r\nWe don't have to go through every single place where we have an \"add to favorite\" button and modify code there.\r\n\r\nNow, we also wanted to make sure that other kinds of conditions were met.\r\n\r\nWe wanted to be able to expand upon this idea of readiness, expand upon the idea of when we're allowed to execute an operation.\r\n\r\nSome examples that we came up with include, we only want to execute this operation if you are actually connected to the network.\r\n\r\nIf you try to add the favorite in while your phone is in airplane mode, for example, we, of course, don't want to try executing our CloudKit operation.\r\n\r\nWe also want to guarantee, perhaps, that maybe we only want to execute an operation if we have access to your location.\r\n\r\nSo we need a way to express this as well.\r\n\r\nOr for example, we only want to execute certain kinds of operations if you are actually logged into the app.\r\n\r\nSo by extending the concept of what it means for an operation to be ready, we can make our operations even more powerful.\r\n\r\nSo hopefully you won't ever see this error, but if you do, this is an example of an operation failing because it was never able to become fully ready to execute.\r\n\r\nIn this case because it was unable to connect to the network.\r\n\r\nSo extending the readiness concept can also be really powerful.\r\n\r\nNext, there were a couple of operations where we found that they were always being done together.\r\n\r\nSo we thought, wouldn't it be neat if instead of having to create the same sequence of operations over and over again, if we could just create one operation and then under the hood it would create the same sequence of operations for us?\r\n\r\nA common example of this is the idea of downloading something and then parsing it to save into a local storage.\r\n\r\nI am sure this is a concept that almost all of you are familiar with.\r\n\r\nSo let's take a look at how we can compose operations to make them simpler.\r\n\r\nSo let's say we have a generic import data operation, and then it's dependent on something and other things are dependent on it.\r\n\r\nWe have this import idea.\r\n\r\nWell, we want this to actually do two things, so it's going to wrap another NSOperation, and this operation is simply going to perform the download.\r\n\r\nIt's a single, isolated piece of work.\r\n\r\nAnd then it's going to create a second operation to parse whatever was downloaded and make it dependent on the download operation so that parsing will always occur after downloading.\r\n\r\nNow, by encapsulating those two operations inside of a larger operation, we can now easily change perhaps, maybe where our data is coming from, what format it's in, and even how we handle errors.\r\n\r\nAnd we only have to do this in one place, inside our import operation, because that's the only thing that the rest of our app knows about.\r\n\r\nNow, you don't always know ahead of time, perhaps, the exact operations that you need to perform.\r\n\r\nIn the WWDC app, we cannot know at compile time how many favorites you've saved to CloudKit, so we needed a way to be able to dynamically compose operations.\r\n\r\nSo we created this wrapper called a Fetch Favorites operation, and since we are using CloudKit, under the hood we are going to perform a CK query operation, because CloudKit is also built on NSOperation.\r\n\r\nSo we are going to perform our first query operation.\r\n\r\nAnd maybe you have every single session favorited at WWDC, so this is going to indicate that there are still more favorites to fetch.\r\n\r\nSo we are going to keep on executing query operations until we have received a response that that's all of them and we've got them all.\r\n\r\nSo by using this composition model, we can still simply express our operation chain as a single with a single \"fetch favorites\" operation, but under the hood, actually be performing many operations, potentially, in sequence.\r\n\r\nNow, in the code, it looks something like this.\r\n\r\nOur operations have an execute method, and this is where they all start doing their work.\r\n\r\nSo the first time the fetch favorite operation starts executing, it's going to set up the initial query.\r\n\r\nWe are going to look for session favorite records created by you.\r\n\r\nSo we are going to construct our query operation and pass it to this method called execute query operation.\r\n\r\nAnd this is the execute query operation.\r\n\r\nAs this query operation completes, we are going to first check, was there an error, and if there was, let's abort the process and handle the error.\r\n\r\nIf there wasn't an error, but instead, there was a cursor, this is how CloudKit tells us that there are still more things for us to fetch.\r\n\r\nSo we're going to create the next CK query operation in the sequence using this cursor and semi-recursively call this execute query operation.\r\n\r\nAnd this is how we can be executing many query operations.\r\n\r\nAnd then if we get neither the cursor nor the error, this is how CloudKit indicates that we have fetched everything, and so we can begin to import the records that we have downloaded.\r\n\r\nNext, during development, there were some times when we came up with some visual glitches, the things that we thought were visual glitches.\r\n\r\nNow, perhaps you've all had the experience of using an app and an alert pops up, and then as you are about to tap the button, another alert pops up.\r\n\r\nAnd you think, oh, great, man, what is even going on now?\r\n\r\nAnd as you are about to tap that button, maybe another alert pops up, and with all of the animations of coming and going, you are no longer even sure if you are back on the first alert or if you are now on the third.\r\n\r\nWe really wanted to avoid this confusing scenario.\r\n\r\nAnother thing we wanted to do is we wanted to guarantee that you could never, ever try to watch more than one video at once.\r\n\r\nThis is something that the WWDC app does not know how to handle correctly, so we wanted to guarantee that no matter what you did, we would never allow you to do that.\r\n\r\nAnother thing we wanted to guarantee is that we would never try to load our underlying database more than once.\r\n\r\nSo we came up with a way of describing mutual exclusivity, the idea that only one of these particular kind of operations can be running at a time.\r\n\r\nNow, you are probably thinking, wow, this is a really complex idea.\r\n\r\nHow would we even do this?\r\n\r\nAnd it is really simple.\r\n\r\nSo let's go back to the alert example.\r\n\r\nLet's say we create an operation to display alert and alert to the user, and we put it onto an operation queue.\r\n\r\nAnd maybe it's there waiting for something else to finish, maybe it's already in the middle of executing.\r\n\r\nWho knows?\r\n\r\nBut then something happens, and we decide to create another alert operation.\r\n\r\nWell, all we need to do is make the second alert operation dependent on the first one.\r\n\r\nAnd this is where cross-queue dependencies are really powerful.\r\n\r\nBecause it does not matter which queue this alert operation is executing on, as long as the second operation is dependent on the first, then the second operation will never execute until after the first operation completes.\r\n\r\nAnd so for some if for some insane reason, we decide to create more alert operations, even more alert operations, as long as we set up these dependencies of the next operation being dependent on the previous, like a singly linked list back in time, we are guaranteeing that our operations will be mutually exclusive.\r\n\r\nThis is really powerful.\r\n\r\nBy using dependencies, we can guarantee correct behavior in our application.\r\n\r\nWe can guarantee that you will never see more than one alert at once.\r\n\r\nWe can guarantee that you will never be able to watch more than one video at a time.\r\n\r\nWe can guarantee that we will never try to load two copies of our data store simultaneously.\r\n\r\nSo those are a taste of some of the challenges that we came up with when writing the WWDC app.\r\n\r\nThere are more.\r\n\r\nBut we think these ones are really cool.\r\n\r\nAnd we came up with what we thought was a pretty neat way to solve them.\r\n\r\nSo let's talk about the sample code.\r\n\r\nOn the WWDC website, under the sample code section, you can find a piece of sample code called Advanced NSOperations.\r\n\r\nAnd this is a simple app to show recent earthquakes.\r\n\r\nBut under the hood, it's built entirely on NSOperations, and the operations that it's using in the app is code that we have extracted from the WWDC app and put into the sample.\r\n\r\nAnd this is code that's been in the app, actually, for a couple of years.\r\n\r\nIt is stable.\r\n\r\nNow, the primary class that this sample code uses is operation.\r\n\r\nAnd this is a basic subclass of NSOperation.\r\n\r\nAnd in the sample code, this operation adds two key features.\r\n\r\nThe first is the idea of a condition, which we will talk about in a second.\r\n\r\nAnd the second is a concept that we call \"observers.\"\r\n\r\nNow, we've got a bunch of different kinds of operations in the sample code.\r\n\r\nWe have group operations, so it's very easy to make operations internally perform more operations.\r\n\r\nWe also have an operation subclass in the sample code that allows you to take an NSURLSession task and wrap it up inside of an NSOperation so that you can make it, perhaps, dependent on something else or make other things dependent on this, or perhaps add conditions or observers to it.\r\n\r\nThere's a simple operation to request your current location.\r\n\r\nThere's one because it's sometimes useful to just simply wait a little bit of time.\r\n\r\nThere's even an operation to show an alert to the user with buttons and block handlers.\r\n\r\nSo lots of great kinds of NSOperation subclasses in the sample code.\r\n\r\nNow, this operation has a concept of a condition.\r\n\r\nAnd a condition is a protocol that we have defined, and it's a way for an operation to express how it generates dependencies, how it defines mutual exclusivity, and also how it extends the concept of readiness.\r\n\r\nSo some kind of conditions that we have provided in the sample code.\r\n\r\nOne is the mutually exclusive generic condition, and this is a way of describing that an operation is mutually exclusive with other kinds of operations with the same generic type.\r\n\r\nWe have a reachability condition in there, so you can simply, with one line of code, express that an operation can only execute if the network is reachable at a very high level.\r\n\r\nAnd we've got a plethora of permission conditions, such as only execute this operation if we have access to a certain CloudKit container, or only execute this operation if we have access to your calendar or to your photo library or to your contacts or whatever else you'd like.\r\n\r\nSo that's conditions.\r\n\r\nAnd the final piece is operation observers.\r\n\r\nAn operation observer is again a protocol type, and it's a way for this value to be notified about significant events in operation lifecycle, such as start or the beginning of execution, the end of execution, and also if the operation decides to produce another operation that should be executed later, such as if an operation decides that it failed and it wants to show an alert, it can produce or generate an alert operation.\r\n\r\nAnd we have a couple of examples of observers, such as timeouts.\r\n\r\nBy simply adding a timeout observer to an operation, that observer is going to watch to make sure that the operation completes within whatever time interval you specified, and if it takes too long, it's going to automatically cancel it.\r\n\r\nOne that I think is really neat is a background observer, so this is an observer that when you attach it to one of these operations is going to watch the state of your UI application, and if your application enters the background, it's going to automatically begin a background task, and then automatically end it when the operation finishes executing.\r\n\r\nSo if you have some sort of critical operation, perhaps you are uploading data to a server and you don't want that to be interrupted or suspended, one way you can accomplish this is by adding one of these background observers to the operation, and it will guarantee that you have some time in the background during which you can complete this operation.\r\n\r\nAnd another one that's really cool is the network activity indicator observer.\r\n\r\nThis is a simple observer you can attach to an operation, and when it begins, it's going to increment a sort of retain count on the activity indicator spinner in the status bar, and then when the operation ends, it's going to decrement that retain count.\r\n\r\nSo you can have multiple networking operations in flight at the same time, and by simply attaching one of these network indicator or, observers it will automatically show and hide the network activity indicator as appropriate.\r\n\r\nIt is no longer this crazy crazy state that you have to manage yourself.\r\n\r\nIt all kind of happens automatically.\r\n\r\nIt's really cool.\r\n\r\nAnd then there are other observers that we have in the sample code for you, such as being able to attach arbitrary blocks to one of those three events and have them react appropriately.\r\n\r\nSo that's a quick look at the sample code.\r\n\r\nOn the surface, it looks like a really simple application, but under the hood, there is lots of really meaty goodness, and I really encourage you to download it and check it out.\r\n\r\nSo, in summary, use operations to abstract the logic in your app.\r\n\r\nBy putting your logic inside of operations, it becomes very easy to change it later, such as how we converted the WWDC app to use CloudKit.\r\n\r\nIt was a simple change for us.\r\n\r\nUse dependencies to express the relationships between your operations.\r\n\r\nIt makes it very simple to guarantee certain kinds of behaviors, that B must always follow A.\r\n\r\nNext, operations allow you to describe complex behaviors, such as mutual exclusivity or composition.\r\n\r\nThese are all simple with operations.\r\n\r\nAnd overall NSOperation allows you to perform some very powerful things with very minimal effort.\r\n\r\nSo we have a couple of related sessions for you.\r\n\r\nImmediately after this session is \"Building Responsive and Efficient Apps with GCD.\"\r\n\r\nWe don't want you to leave GCD behind.\r\n\r\nIt is still a perfectly appropriate technology to use.\r\n\r\nSo I encourage you to go to this session or watch the video and see when you should be using GCD in your apps.\r\n\r\nAnd then if you want to see more about how our frameworks use NSOperation, you can watch the \"CloudKit Tips and Tricks\" session from this year or the \"Advanced CloudKit\" session from last year.\r\n\r\nLike I said, we have sample code available on the WWDC website.\r\n\r\nI encourage you to check it out.\r\n\r\nI also want you to read the 'Threading Programming Guide' in the Developer Library.\r\n\r\nThis has a lot of really great information on other ways that you can use NSOperation.\r\n\r\nAnd if you need any technical support, we encourage you to post your questions in the Developer Forums or contact DTS.\r\n\r\nThank you very much, and have a great rest of the conference.\r\n\r\n[ Applause ]\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}